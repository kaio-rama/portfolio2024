---
title: 'Visual Loosers: visual generator with GLSL - English Manual'
publishedAt: '2024-09-03'
summary: 'Discover Visual Loosers, and how to use it with a few knowledges of GLSL.'
---

Check VisualLoosers on <a href="https://kaio-rama.github.io/visualsloosers/" target="blank" style={{color: 'blue'}}>https://kaio-rama.github.io/visualsloosers/</a>

### What is Visual Loosers?

Basically, it's a visual generator using GLSL code. This means that when you enter the website, you'll see a text editor where you can write code, and it will be rendered when you click the "Run Code" button. This code will be executed on the Canvas that forms the display for the rest of the application. Simple, right? You can start seeing results with the "Random" button, which "generates" random codes (pre-established and generated by AI) to help you get familiar with the app interface.

Visual Loosers is written in JavaScript and implements WebGL through p5.js.

Created by Ramiro Canevari (a.k.a. kaio-rama).

### To create shader code that works in your application, users need to know the following key parameters and information:

1. **Available Uniforms**:
   - `time`: A floating-point value that represents the time in seconds since execution began. Useful for animations.
   - `resolution`: A two-component vector (`vec2`) that represents the size of the canvas in pixels. It's used to normalize coordinates and adapt the visuals to the screen resolution.

2. **Coordinates**:
   - `gl_FragCoord.xy`: Coordinates of the current fragment in screen space. Combined with `resolution`, they allow for effects based on position.

3. **GLSL Data Types**:
   - **Vec2**: A two-component vector (e.g., `vec2(1.0, 0.0)`).
   - **Vec3**: A three-component vector, commonly used for RGB colors (e.g., `vec3(1.0, 0.0, 0.0)`).
   - **Vec4**: A four-component vector, including alpha (e.g., `vec4(1.0, 0.0, 0.0, 1.0)`).

4. **Common Functions**:
   - `sin()`, `cos()`: Trigonometric functions useful for creating wave patterns.
   - `length(vec2)`: Calculates the distance from the origin, useful for radial effects.

5. **Shader Structure**:
   - The shader must contain a `main()` function that computes the color of each pixel (`gl_FragColor`).

### Basic Example:
```glsl
uniform float time;
uniform vec2 resolution;

void main() {
    vec2 uv = gl_FragCoord.xy / resolution;  // Normalize coordinates
    vec3 color = 0.5 + 0.5 * cos(time + uv.xyx * vec3(1.0, 1.0, 1.0));  // Animated color
    gl_FragColor = vec4(color, 1.0);  // Assign color to fragment
}

This code generates an animated color gradient. Users can modify the calculation of uv and color to create different visuals.
Basic Functions of the Visual Generator

    Main Function in the Fragment Shader:

glsl

void main() {
    vec2 uv = gl_FragCoord.xy / resolution;
    vec3 color = 0.5 + 0.5 * cos(time + uv.xyx + vec3(0, 2, 4));
    gl_FragColor = vec4(color, 1.0);
}

    gl_FragCoord: Provides the coordinates of the current fragment in the window.
    resolution: Uniform that indicates the canvas resolution (width and height).
    time: Uniform that indicates the time in seconds since the animation started.
    uv: Normalized coordinates of the fragment (from 0 to 1).
    color: Color calculated using a mathematical function.
    gl_FragColor: Final color of the fragment.

Usable Functions and Parameters in the Code

    Uniforms:
    uniform vec2 resolution;
        Description: The resolution of the canvas (width and height).
        Usage: Adjust the resolution in the shader so that coordinate and color calculations adapt to the canvas size.
    uniform float time;
        Description: Time in seconds since the start of the animation.
        Usage: Allows for animation and the creation of dynamic effects based on time.

    Mathematical Functions in GLSL:

In the fragment shader, you can use various mathematical functions to create visual effects:

    sin(x): Sine of x.
    cos(x): Cosine of x.
    abs(x): Absolute value of x.
    mod(x, y): Remainder of x divided by y.
    mix(x, y, a): Linear interpolation between x and y using a as the mix factor.
    smoothstep(edge0, edge1, x): Smooth interpolation between 0 and 1 in the range [edge0, edge1].

How to Use These Functions:
Modify the Fragment Shader:

    Write your code in the editor area. Use the uniform variables (resolution, time) and mathematical functions to create visual effects.
    The provided examples can be copied and pasted into the editor to see how they affect the canvas.

Interact with the Code:

    Run Code Button: Compiles and applies the written fragment shader code to the canvas.
    You can adjust the code in real-time and see the changes directly on the canvas.

Additional Considerations:

    Shader Errors: If the GLSL code contains errors, the shader might not compile correctly. Make sure there are no syntax errors in the code.
    Performance: Complex calculations can affect performance, especially on devices with lower processing power.